-- Complete PC UI Library
local library = {
    directory = "milenium",
    folders = {
        "/fonts",
        "/configs",
    },
    flags = {},
    config_flags = {},
    connections = {},   
    notifications = {notifs = {}},
    current_open = nil,
    cache = {}
}

library.__index = library

-- Services
local Services = {
    UserInputService = game:GetService("UserInputService"),
    Players = game:GetService("Players"),
    Workspace = game:GetService("Workspace"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    HttpService = game:GetService("HttpService"),
    GuiService = game:GetService("GuiService"),
    Lighting = game:GetService("Lighting"),
    RunService = game:GetService("RunService"),
    Stats = game:GetService("Stats"),
    CoreGui = game:GetService("CoreGui"),
    Debris = game:GetService("Debris"),
    TweenService = game:GetService("TweenService"),
    SoundService = game:GetService("SoundService"),
    TeleportService = game:GetService("TeleportService")
}

-- Local variables
local uis = Services.UserInputService
local players = Services.Players
local ws = Services.Workspace
local rs = Services.ReplicatedStorage
local http_service = Services.HttpService
local gui_service = Services.GuiService
local lighting = Services.Lighting
local run = Services.RunService
local stats = Services.Stats
local coregui = Services.CoreGui
local debris = Services.Debris
local tween_service = Services.TweenService
local sound_service = Services.SoundService

local vec2 = Vector2.new
local vec3 = Vector3.new
local dim2 = UDim2.new
local dim = UDim.new 
local rect = Rect.new
local cfr = CFrame.new
local empty_cfr = cfr()
local point_object_space = empty_cfr.PointToObjectSpace
local angle = CFrame.Angles
local dim_offset = UDim2.fromOffset

local color = Color3.new
local rgb = Color3.fromRGB
local hex = Color3.fromHex
local hsv = Color3.fromHSV
local rgbseq = ColorSequence.new
local rgbkey = ColorSequenceKeypoint.new
local numseq = NumberSequence.new
local numkey = NumberSequenceKeypoint.new

local camera = ws.CurrentCamera
local lp = players.LocalPlayer 
local mouse = lp:GetMouse() 
local gui_offset = gui_service:GetGuiInset().Y

local max = math.max 
local floor = math.floor 
local min = math.min 
local abs = math.abs 
local noise = math.noise
local rad = math.rad 
local random = math.random 
local pow = math.pow 
local sin = math.sin 
local pi = math.pi 
local tan = math.tan 
local atan2 = math.atan2 
local clamp = math.clamp 

local insert = table.insert 
local find = table.find 
local remove = table.remove
local concat = table.concat

-- Library init
getgenv().library = library

local themes = {
    preset = {
        accent = hex("FF0035"),
    }, 
    utility = {
        accent = {
            BackgroundColor3 = {}, 	
            TextColor3 = {}, 
            ImageColor3 = {}, 
            ScrollBarImageColor3 = {} 
        },
    }
}

local keys = {
    [Enum.KeyCode.LeftShift] = "LS",
    [Enum.KeyCode.RightShift] = "RS",
    [Enum.KeyCode.LeftControl] = "LC",
    [Enum.KeyCode.RightControl] = "RC",
    [Enum.KeyCode.Insert] = "INS",
    [Enum.KeyCode.Backspace] = "BS",
    [Enum.KeyCode.Return] = "Ent",
    [Enum.KeyCode.LeftAlt] = "LA",
    [Enum.KeyCode.RightAlt] = "RA",
    [Enum.KeyCode.CapsLock] = "CAPS",
    [Enum.KeyCode.One] = "1",
    [Enum.KeyCode.Two] = "2",
    [Enum.KeyCode.Three] = "3",
    [Enum.KeyCode.Four] = "4",
    [Enum.KeyCode.Five] = "5",
    [Enum.KeyCode.Six] = "6",
    [Enum.KeyCode.Seven] = "7",
    [Enum.KeyCode.Eight] = "8",
    [Enum.KeyCode.Nine] = "9",
    [Enum.KeyCode.Zero] = "0",
    [Enum.KeyCode.KeypadOne] = "Num1",
    [Enum.KeyCode.KeypadTwo] = "Num2",
    [Enum.KeyCode.KeypadThree] = "Num3",
    [Enum.KeyCode.KeypadFour] = "Num4",
    [Enum.KeyCode.KeypadFive] = "Num5",
    [Enum.KeyCode.KeypadSix] = "Num6",
    [Enum.KeyCode.KeypadSeven] = "Num7",
    [Enum.KeyCode.KeypadEight] = "Num8",
    [Enum.KeyCode.KeypadNine] = "Num9",
    [Enum.KeyCode.KeypadZero] = "Num0",
    [Enum.KeyCode.Minus] = "-",
    [Enum.KeyCode.Equals] = "=",
    [Enum.KeyCode.Tilde] = "~",
    [Enum.KeyCode.LeftBracket] = "[",
    [Enum.KeyCode.RightBracket] = "]",
    [Enum.KeyCode.RightParenthesis] = ")",
    [Enum.KeyCode.LeftParenthesis] = "(",
    [Enum.KeyCode.Semicolon] = ",",
    [Enum.KeyCode.Quote] = "'",
    [Enum.KeyCode.BackSlash] = "\\",
    [Enum.KeyCode.Comma] = ",",
    [Enum.KeyCode.Period] = ".",
    [Enum.KeyCode.Slash] = "/",
    [Enum.KeyCode.Asterisk] = "*",
    [Enum.KeyCode.Plus] = "+",
    [Enum.KeyCode.Period] = ".",
    [Enum.KeyCode.Backquote] = "`",
    [Enum.UserInputType.MouseButton1] = "MB1",
    [Enum.UserInputType.MouseButton2] = "MB2",
    [Enum.UserInputType.MouseButton3] = "MB3",
    [Enum.KeyCode.Escape] = "ESC",
    [Enum.KeyCode.Space] = "SPC",
}

for _, path in next, library.folders do 
    if not isfolder(library.directory .. path) then
        makefolder(library.directory .. path)
    end
end

local flags = library.flags 
local config_flags = library.config_flags
local notifications = library.notifications 

-- Font registration function
local function Register_Font(Name, Weight, Style, Asset)
    if not isfile(Asset.Id) then
        writefile(Asset.Id, Asset.Font)
    end

    if isfile(Name .. ".font") then
        delfile(Name .. ".font")
    end

    local Data = {
        name = Name,
        faces = {
            {
                name = "Normal",
                weight = Weight,
                style = Style,
                assetId = getcustomasset(Asset.Id),
            },
        },
    }

    writefile(Name .. ".font", http_service:JSONEncode(Data))
    return getcustomasset(Name .. ".font")
end

-- Font setup
local fonts = {}
do
    local Medium = Register_Font("Medium", 200, "Normal", {
        Id = "Medium.ttf",
        Font = game:HttpGet("https://github.com/i77lhm/storage/raw/refs/heads/main/fonts/Inter_28pt-Medium.ttf"),
    })

    local SemiBold = Register_Font("SemiBold", 200, "Normal", {
        Id = "SemiBold.ttf",
        Font = game:HttpGet("https://github.com/i77lhm/storage/raw/refs/heads/main/fonts/Inter_28pt-SemiBold.ttf"),
    })

    fonts = {
        small = Font.new(Medium, Enum.FontWeight.Regular, Enum.FontStyle.Normal),
        font = Font.new(SemiBold, Enum.FontWeight.Regular, Enum.FontStyle.Normal),
    }
end

-- Library functions
function library:tween(obj, properties, easing_style, time) 
    local tween = tween_service:Create(obj, TweenInfo.new(time or 0.25, easing_style or Enum.EasingStyle.Quint, Enum.EasingDirection.InOut, 0, false, 0), properties)
    tween:Play()
    return tween
end

function library:resizify(frame) 
    local Frame = Instance.new("TextButton")
    Frame.Position = dim2(1, -10, 1, -10)
    Frame.BorderColor3 = rgb(0, 0, 0)
    Frame.Size = dim2(0, 10, 0, 10)
    Frame.BorderSizePixel = 0
    Frame.BackgroundColor3 = rgb(255, 255, 255)
    Frame.Parent = frame
    Frame.BackgroundTransparency = 1 
    Frame.Text = ""

    local resizing = false 
    local start_size 
    local start 
    local og_size = frame.Size  

    Frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            resizing = true
            start = input.Position
            start_size = frame.Size
        end
    end)

    Frame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            resizing = false
        end
    end)

    library:connection(uis.InputChanged, function(input, game_event) 
        if resizing and input.UserInputType == Enum.UserInputType.MouseMovement then
            local viewport_x = camera.ViewportSize.X
            local viewport_y = camera.ViewportSize.Y

            local current_size = dim2(
                start_size.X.Scale,
                clamp(
                    start_size.X.Offset + (input.Position.X - start.X),
                    og_size.X.Offset,
                    viewport_x
                ),
                start_size.Y.Scale,
                clamp(
                    start_size.Y.Offset + (input.Position.Y - start.Y),
                    og_size.Y.Offset,
                    viewport_y
                )
            )

            library:tween(frame, {Size = current_size}, Enum.EasingStyle.Linear, 0.05)
        end
    end)
end 

function library:next_flag()
    local index = 0
    for _ in pairs(library.flags) do
        index = index + 1
    end
    local str = string.format("flagnumber%s", index + 1)
    return str
end 

function library:mouse_in_frame(uiobject)
    local y_cond = uiobject.AbsolutePosition.Y <= mouse.Y and mouse.Y <= uiobject.AbsolutePosition.Y + uiobject.AbsoluteSize.Y
    local x_cond = uiobject.AbsolutePosition.X <= mouse.X and mouse.X <= uiobject.AbsolutePosition.X + uiobject.AbsoluteSize.X
    return (y_cond and x_cond)
end

function library:draggify(frame)
    local dragging = false 
    local start_size = frame.Position
    local start 

    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            start = input.Position
            start_size = frame.Position
        end
    end)

    frame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)

    library:connection(uis.InputChanged, function(input, game_event) 
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local viewport_x = camera.ViewportSize.X
            local viewport_y = camera.ViewportSize.Y

            local current_position = dim2(
                0,
                clamp(
                    start_size.X.Offset + (input.Position.X - start.X),
                    0,
                    viewport_x - frame.Size.X.Offset
                ),
                0,
                clamp(
                    start_size.Y.Offset + (input.Position.Y - start.Y),
                    0,
                    viewport_y - frame.Size.Y.Offset
                )
            )

            library:tween(frame, {Position = current_position}, Enum.EasingStyle.Linear, 0.05)
            library:close_element()
        end
    end)
end 

function library:convert(str)
    local values = {}
    for value in string.gmatch(str, "[^,]+") do
        insert(values, tonumber(value))
    end
    if #values == 4 then              
        return unpack(values)
    else 
        return nil
    end
end

function library:convert_enum(enum)
    local enum_parts = {}
    for part in string.gmatch(enum, "[%w_]+") do
        insert(enum_parts, part)
    end
    local enum_table = Enum
    for i = 2, #enum_parts do
        local enum_item = enum_table[enum_parts[i]]
        enum_table = enum_item
    end
    return enum_table
end

local config_holder
function library:update_config_list() 
    if not config_holder then 
        return 
    end
    local list = {}
    for _, file in pairs(listfiles(library.directory .. "/configs")) do
        local name = file:gsub(library.directory .. "/configs\\", ""):gsub(".cfg", ""):gsub(library.directory .. "\\configs\\", "")
        insert(list, name)
    end
    if config_holder.refresh_options then
        config_holder.refresh_options(list)
    end
end 

function library:get_config()
    local Config = {}
    for _, v in pairs(flags) do
        if type(v) == "table" and v.key then
            Config[_] = {active = v.active, mode = v.mode, key = tostring(v.key)}
        elseif type(v) == "table" and v["Transparency"] and v["Color"] then
            Config[_] = {Transparency = v["Transparency"], Color = v["Color"]:ToHex()}
        else
            Config[_] = v
        end
    end 
    return http_service:JSONEncode(Config)
end

function library:load_config(config_json) 
    local config = http_service:JSONDecode(config_json)
    for _, v in pairs(config) do 
        local function_set = library.config_flags[_]
        if _ == "config_name_list" then 
            continue 
        end
        if function_set then 
            if type(v) == "table" and v["Transparency"] and v["Color"] then
                function_set(hex(v["Color"]), v["Transparency"])
            elseif type(v) == "table" and v["active"] then 
                function_set(v)
            else
                function_set(v)
            end
        end 
    end 
end 

function library:round(number, float) 
    local multiplier = 1 / (float or 1)
    return floor(number * multiplier + 0.5) / multiplier
end 

function library:apply_theme(instance, theme, property) 
    if not themes.utility[theme] or not themes.utility[theme][property] then
        themes.utility[theme] = themes.utility[theme] or {}
        themes.utility[theme][property] = {}
    end
    insert(themes.utility[theme][property], instance)
end

function library:update_theme(theme, color)
    if themes.utility[theme] then
        for _, property in pairs(themes.utility[theme]) do 
            for _, object in ipairs(property) do 
                if object then
                    object[theme] = color 
                end
            end 
        end 
    end
    themes.preset[theme] = color 
end 

function library:connection(signal, callback)
    local connection = signal:Connect(callback)
    insert(library.connections, connection)
    return connection 
end

function library:close_element(new_path) 
    local open_element = library.current_open
    if open_element and new_path ~= open_element then
        if open_element.set_visible then
            open_element.set_visible(false)
        end
        open_element.open = false
    end 
    if new_path ~= open_element then 
        library.current_open = new_path or nil
    end
end 

function library:create(instance, options)
    local ins = Instance.new(instance) 
    for prop, value in pairs(options) do 
        ins[prop] = value
    end
    return ins 
end

function library:unload_menu() 
    if library["items"] then 
        library["items"]:Destroy()
    end
    if library["other"] then 
        library["other"]:Destroy()
    end 
    for _, connection in ipairs(library.connections) do 
        connection:Disconnect() 
    end
    library = nil 
end 

-- Window function (main UI container)
function library:window(properties)
    local cfg = { 
        suffix = properties.suffix or properties.Suffix or "tech",
        name = properties.name or properties.Name or "nebula",
        game_name = properties.gameInfo or properties.game_info or properties.GameInfo or "Nexus",
        size = properties.size or properties.Size or dim2(0, 700, 0, 565),
        selected_tab = nil,
        items = {},
        tween = nil,
    }
    
    library["items"] = library:create("ScreenGui", {
        Parent = coregui,
        Name = "LibraryUI",
        Enabled = true,
        ZIndexBehavior = Enum.ZIndexBehavior.Global,
        IgnoreGuiInset = true,
    })
    
    library["other"] = library:create("ScreenGui", {
        Parent = coregui,
        Name = "LibraryOther",
        Enabled = false,
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
        IgnoreGuiInset = true,
    }) 

    local items = cfg.items
    items["main"] = library:create("Frame", {
        Parent = library["items"],
        Size = cfg.size,
        Name = "MainFrame",
        Position = dim2(0.5, -cfg.size.X.Offset / 2, 0.5, -cfg.size.Y.Offset / 2),
        BorderColor3 = rgb(0, 0, 0),
        BorderSizePixel = 0,
        BackgroundColor3 = rgb(14, 14, 16)
    })
    
    library:create("UICorner", {
        Parent = items["main"],
        CornerRadius = dim(0, 10)
    })
    
    library:create("UIStroke", {
        Color = rgb(23, 23, 29),
        Parent = items["main"],
        ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    })
    
    -- Add more UI elements here based on your structure...
    
    -- Draggable and resizable
    library:draggify(items["main"])
    library:resizify(items["main"])
    
    function cfg.toggle_menu(bool) 
        library["items"].Enabled = bool
    end 
    
    return setmetatable(cfg, library)
end

-- Tab function
function library:tab(properties)
    local cfg = {
        name = properties.name or properties.Name or "visuals", 
        icon = properties.icon or properties.Icon or "http://www.roblox.com/asset/?id=6034767608",
        tabs = properties.tabs or properties.Tabs or {"Main", "Misc.", "Settings"},
        pages = {},
        current_multi = nil,
        items = {},
    }
    
    -- Implementation for tab creation...
    return setmetatable(cfg, library)
end

-- Section function
function library:section(properties)
    local cfg = {
        name = properties.name or properties.Name or "section", 
        side = properties.side or properties.Side or "left",
        default = properties.default or properties.Default or false,
        size = properties.size or properties.Size or 0.5, 
        icon = properties.icon or properties.Icon or "http://www.roblox.com/asset/?id=6022668898",
        fading_toggle = properties.fading or properties.Fading or false,
        items = {},
    }
    
    -- Implementation for section creation...
    return setmetatable(cfg, library)
end

-- Toggle function
function library:toggle(options)
    local cfg = {
        enabled = options.default or false,
        name = options.name or "Toggle",
        info = options.info or nil,
        flag = options.flag or library:next_flag(),
        type = options.type and string.lower(options.type) or "toggle",
        default = options.default or false,
        folding = options.folding or false, 
        callback = options.callback or function() end,
        items = {},
        seperator = options.seperator or false,
    }

    flags[cfg.flag] = cfg.default

    -- Implementation for toggle creation...
    function cfg.set(bool)
        cfg.callback(bool)
        flags[cfg.flag] = bool
    end 
    
    cfg.set(cfg.default)
    config_flags[cfg.flag] = cfg.set

    return setmetatable(cfg, library)
end

-- Slider function
function library:slider(options)
    local cfg = {
        name = options.name or nil,
        suffix = options.suffix or "",
        flag = options.flag or library:next_flag(),
        callback = options.callback or function() end, 
        info = options.info or nil,
        min = options.min or options.minimum or 0,
        max = options.max or options.maximum or 100,
        intervals = options.interval or options.decimal or 1,
        default = options.default or 10,
        value = options.default or 10, 
        seperator = options.seperator or true,
        dragging = false,
        items = {}
    }

    flags[cfg.flag] = cfg.default

    function cfg.set(value)
        cfg.value = clamp(library:round(value, cfg.intervals), cfg.min, cfg.max)
        flags[cfg.flag] = cfg.value
        cfg.callback(flags[cfg.flag])
    end

    cfg.set(cfg.default)
    config_flags[cfg.flag] = cfg.set

    return setmetatable(cfg, library)
end

-- Dropdown function
function library:dropdown(options)
    local cfg = {
        name = options.name or nil,
        info = options.info or nil,
        flag = options.flag or library:next_flag(),
        options = options.items or {""},
        callback = options.callback or function() end,
        multi = options.multi or false,
        scrolling = options.scrolling or false,
        width = options.width or 130,
        open = false,
        option_instances = {},
        multi_items = {},
        ignore = options.ignore or false,
        items = {},
        y_size = 0,
        seperator = options.seperator or true,
    }

    cfg.default = options.default or (cfg.multi and {cfg.options[1]}) or cfg.options[1] or "None"
    flags[cfg.flag] = cfg.default

    function cfg.set(value)
        local selected = {}
        local isTable = type(value) == "table"

        for _, option in ipairs(cfg.option_instances) do 
            if option.Text == value or (isTable and find(value, option.Text)) then 
                insert(selected, option.Text)
                cfg.multi_items = selected
                if option.TextColor3 then
                    option.TextColor3 = themes.preset.accent
                end
            else
                if option.TextColor3 then
                    option.TextColor3 = rgb(72, 72, 73)
                end
            end
        end

        flags[cfg.flag] = isTable and selected or selected[1] or ""
        cfg.callback(flags[cfg.flag]) 
    end

    flags[cfg.flag] = cfg.multi and {} or ""
    config_flags[cfg.flag] = cfg.set
    cfg.set(cfg.default)

    return setmetatable(cfg, library)
end

-- Colorpicker function
function library:colorpicker(options)
    local cfg = {
        name = options.name or "Color", 
        flag = options.flag or library:next_flag(),
        color = options.color or color(1, 1, 1),
        alpha = options.alpha and 1 - options.alpha or 0,
        open = false, 
        callback = options.callback or function() end,
        items = {},
        seperator = options.seperator or false,
    }

    local h, s, v = cfg.color:ToHSV() 
    local a = cfg.alpha 

    flags[cfg.flag] = {Color = cfg.color, Transparency = cfg.alpha}

    function cfg.set(color, alpha)
        if type(color) == "boolean" then 
            return
        end 

        if color then 
            h, s, v = color:ToHSV()
        end
        
        if alpha then 
            a = alpha
        end 
        
        local Color = hsv(h, s, v)
        flags[cfg.flag] = {
            Color = Color,
            Transparency = a 
        }
        cfg.callback(Color, a)
    end
    
    cfg.set(cfg.color, cfg.alpha)
    config_flags[cfg.flag] = cfg.set

    return setmetatable(cfg, library)
end

-- Keybind function
function library:keybind(options)
    local cfg = {
        flag = options.flag or library:next_flag(),
        callback = options.callback or function() end,
        name = options.name or nil, 
        ignore_key = options.ignore or false, 
        key = options.key or nil, 
        mode = options.mode or "Toggle",
        active = options.default or false, 
        open = false,
        binding = nil, 
        hold_instances = {},
        items = {},
    }

    flags[cfg.flag] = {
        mode = cfg.mode,
        key = cfg.key, 
        active = cfg.active
    }

    function cfg.set(input)
        if type(input) == "boolean" then 
            cfg.active = input
            if cfg.mode == "Always" then 
                cfg.active = true
            end
        elseif type(input) == "table" then 
            cfg.key = input.key or "NONE"
            cfg.mode = input.mode or "Toggle"
            if input.active then
                cfg.active = input.active
            end
        end 

        cfg.callback(cfg.active)
        flags[cfg.flag] = {
            mode = cfg.mode,
            key = cfg.key, 
            active = cfg.active
        }
    end
    
    cfg.set({mode = cfg.mode, active = cfg.active, key = cfg.key})           
    config_flags[cfg.flag] = cfg.set

    return setmetatable(cfg, library)
end

-- Button function
function library:button(options)
    local cfg = {
        name = options.name or "Button",
        callback = options.callback or function() end,
        items = {},
    }
    
    return setmetatable(cfg, library)
end

-- Label function
function library:label(options)
    local cfg = {
        name = options.name or "Label",
        seperator = options.seperator or false,
        info = options.info or nil, 
        items = {},
    }

    return setmetatable(cfg, library)
end

-- Textbox function
function library:textbox(options)
    local cfg = {
        name = options.name or "TextBox",
        placeholder = options.placeholder or "type here...",
        default = options.default or "",
        flag = options.flag or library:next_flag(),
        callback = options.callback or function() end,
        visible = options.visible or true,
        items = {},
    }

    flags[cfg.flag] = cfg.default

    function cfg.set(text) 
        flags[cfg.flag] = text
        cfg.callback(text)
    end 
        
    if cfg.default then 
        cfg.set(cfg.default) 
    end

    config_flags[cfg.flag] = cfg.set

    return setmetatable(cfg, library)
end

-- Notification system
function notifications:refresh_notifs() 
    local offset = 50
    for i, v in ipairs(notifications.notifs) do
        local Position = vec2(20, offset)
        library:tween(v, {Position = dim_offset(Position.X, Position.Y)}, Enum.EasingStyle.Quad, 0.4)
        offset += (v.AbsoluteSize.Y + 10)
    end
    return offset
end

function notifications:create_notification(options)
    local cfg = {
        name = options.name or "Notification",
        info = options.info or "This is extra info!",
        lifetime = options.lifetime or 3,
        items = {},
    }

    local items = cfg.items
    items["notification"] = library:create("Frame", {
        Parent = library["items"],
        Size = dim2(0, 210, 0, 53),
        Name = "Notification",
        BorderColor3 = rgb(0, 0, 0),
        BorderSizePixel = 0,
        BackgroundTransparency = 1,
        AnchorPoint = vec2(1, 0),
        AutomaticSize = Enum.AutomaticSize.Y,
        BackgroundColor3 = rgb(14, 14, 16)
    })
    
    -- Add notification UI elements...
    
    local index = #notifications.notifs + 1
    notifications.notifs[index] = items["notification"]
    
    local offset = notifications:refresh_notifs()
    items["notification"].Position = dim_offset(20, offset)

    library:tween(items["notification"], {AnchorPoint = vec2(0, 0)}, Enum.EasingStyle.Quad, 1)

    task.spawn(function()
        task.wait(cfg.lifetime)
        notifications.notifs[index] = nil
        library:tween(items["notification"], {AnchorPoint = vec2(1, 0)}, Enum.EasingStyle.Quad, 1)
        task.wait(1)
        items["notification"]:Destroy() 
    end)
end

-- Initialize config system
-- Config System Implementation
function library:init_config(window) 
    window:seperator({name = "Settings"})
    local main, playerlist = window:tab({name = "Configs", tabs = {"Main", "Playerlist"}})
    
    local column = main:column({})
    local section = column:section({name = "Configs", size = 1, default = false, icon = "rbxassetid://139628202576511"})
    
    -- Config list
    config_holder = section:list({
        options = {"Default", "Backup", "AutoSave"},
        callback = function(option)
            flags["config_name_list"] = option
        end, 
        flag = "config_name_list"
    })
    
    -- Initial population of config list
    library:update_config_list()
    
    local column = main:column({})
    local section = column:section({name = "Settings", side = "right", size = 1, default = false, icon = "rbxassetid://129380150574313"})
    
    -- Config name input
    section:textbox({
        name = "Config name:", 
        placeholder = "Enter config name...",
        flag = "config_name_text"
    })
    
    -- Save button
    section:button({
        name = "Save",
        callback = function()
            pcall(function()
                local config_name = flags["config_name_text"] or flags["config_name_list"]
                if not config_name or config_name == "" then
                    notifications:create_notification({
                        name = "Configs",
                        info = "Please enter a config name!",
                        lifetime = 3
                    })
                    return
                end
                
                writefile(library.directory .. "/configs/" .. config_name .. ".cfg", library:get_config())
                library:update_config_list()
                notifications:create_notification({
                    name = "Configs",
                    info = "Saved config to:\n" .. config_name,
                    lifetime = 3
                })
            end)
        end
    })

    -- Overwrite button
    section:button({
        name = "Overwrite",
        callback = function()
            pcall(function()
                local config_name = flags["config_name_list"]
                if not config_name then
                    notifications:create_notification({
                        name = "Configs",
                        info = "Please select a config to overwrite!",
                        lifetime = 3
                    })
                    return
                end
                
                writefile(library.directory .. "/configs/" .. config_name .. ".cfg", library:get_config())
                library:update_config_list()
                notifications:create_notification({
                    name = "Configs",
                    info = "Overwrote config:\n" .. config_name,
                    lifetime = 3
                })
            end)
        end
    })

    -- Load button
    section:button({
        name = "Load",
        callback = function()
            pcall(function()
                local config_name = flags["config_name_list"]
                if not config_name then
                    notifications:create_notification({
                        name = "Configs",
                        info = "Please select a config to load!",
                        lifetime = 3
                    })
                    return
                end
                
                local config_path = library.directory .. "/configs/" .. config_name .. ".cfg"
                if not isfile(config_path) then
                    notifications:create_notification({
                        name = "Configs",
                        info = "Config file not found!",
                        lifetime = 3
                    })
                    return
                end
                
                library:load_config(readfile(config_path))
                library:update_config_list()
                notifications:create_notification({
                    name = "Configs",
                    info = "Loaded config:\n" .. config_name,
                    lifetime = 3
                })
            end)
        end
    })

    -- Delete button
    section:button({
        name = "Delete",
        callback = function()
            pcall(function()
                local config_name = flags["config_name_list"]
                if not config_name then
                    notifications:create_notification({
                        name = "Configs",
                        info = "Please select a config to delete!",
                        lifetime = 3
                    })
                    return
                end
                
                local config_path = library.directory .. "/configs/" .. config_name .. ".cfg"
                if not isfile(config_path) then
                    notifications:create_notification({
                        name = "Configs",
                        info = "Config file not found!",
                        lifetime = 3
                    })
                    return
                end
                
                delfile(config_path)
                library:update_config_list()
                notifications:create_notification({
                    name = "Configs",
                    info = "Deleted config:\n" .. config_name,
                    lifetime = 3
                })
            end)
        end
    })

    -- Theme customization
    section:colorpicker({
        name = "Menu Accent", 
        callback = function(color, alpha) 
            library:update_theme("accent", color) 
        end, 
        color = themes.preset.accent
    })
    
    -- Menu toggle keybind
    section:keybind({
        name = "Menu Bind", 
        key = Enum.KeyCode.Insert, 
        callback = function(bool) 
            if window.toggle_menu then
                window.toggle_menu(bool) 
            end
        end, 
        seperator = true, 
        default = true
    })

    -- Server utilities
    local _request = (http_request and http_request) or (request and request) or (http and http.request) or syn.request

    section:button({
        name = "Join Lowest Server", 
        callback = function()
            local Servers = string.format("https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=Asc&limit=100", tostring(game.PlaceId))
    
            local ListServers = function(cursor)
                local Raw = game:HttpGet(Servers .. ((cursor and "&cursor="..cursor) or ""))
                return Services.HttpService:JSONDecode(Raw)
            end
    
            local Server, Next
            repeat
                local Servers = ListServers(Next)
                Server = Servers.data[1]
                Next = Servers.nextPageCursor
            until Server
    
            if Server.id == game.JobId then
                library.notifications:create_notification({
                    name = "Server",
                    info = "You are currently in the smallest server!",
                    lifetime = 10
                })
                return  
            end 
            
            Services.TeleportService:TeleportToPlaceInstance(game.PlaceId, Server.id)
        end
    })

    section:button({
        name = "Server Hop", 
        callback = function()
            local Servers = {}
            local Request = _request({
                Url = string.format("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Desc&limit=100&excludeFullGames=true", tostring(game.PlaceId))
            })
            local Body = Services.HttpService:JSONDecode(Request.Body)
    
            if Body and Body.data then
                for _, Value in pairs(Body.data) do
                    if type(Value) == "table" and tonumber(Value.playing) and tonumber(Value.maxPlayers) and Value.playing < Value.maxPlayers and Value.id ~= game.JobId then
                        table.insert(Servers, 1, Value.id)
                    end
                end
            end
    
            if #Servers > 0 then
                Services.TeleportService:TeleportToPlaceInstance(game.PlaceId, Servers[math.random(1, #Servers)])
            else
                notifications:create_notification({
                    name = "Server",
                    info = "No available servers found!",
                    lifetime = 3
                })
            end
        end
    })

    section:button({
        name = "Rejoin", 
        callback = function()
            Services.TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId)
        end
    })
    
    -- Playerlist section
    local _column = playerlist:column({})
    local _section = _column:section({name = "Players", size = 1, default = false})

    local plr_list = _section:list({
        options = {}, 
        flag = "player_list"
    })

    _column = playerlist:column({})
    _section = _column:section({name = "Player Options", size = 1, default = false, side = 'right'})

    local _playerlabel = _section:label({name = "Selected Player : None"})

    -- Update selected player label
    task.spawn(function()
        while task.wait(0.1) do
            local selected_player = flags["player_list"] or "None"
            if _playerlabel.set then
                _playerlabel.set(string.format("Selected Player : %s", selected_player))
            end
        end
    end)

    local _statuslabel = _section:label({name = "Status : None"})

    -- Player management lists
    library.priority = library.priority or {}
    library.whitelist = library.whitelist or {}

    -- Update player status
    task.spawn(function()
        while task.wait(0.1) do
            local playervalue = flags["player_list"]
            local status = "None"

            if playervalue ~= nil then
                if table.find(library.priority, playervalue) then
                    status = "<font color='rgb(255,0,0)'>Priority</font>"
                elseif table.find(library.whitelist, playervalue) then
                    status = "<font color='rgb(0,255,0)'>Whitelisted</font>"
                else
                    status = "None"
                end
            else
                status = "None"
            end

            if _statuslabel.set then
                _statuslabel.set(string.format("Status : %s", status))
            end
        end
    end)

    -- Player management buttons
    _section:button({
        name = "Prioritise", 
        callback = function()
            if not flags["player_list"] then 
                notifications:create_notification({
                    name = "Player List",
                    info = "Please select a player first!",
                    lifetime = 3
                })
                return 
            end
            
            local player = flags["player_list"]
            
            -- Remove from whitelist if present
            if table.find(library.whitelist, player) then
                table.remove(library.whitelist, table.find(library.whitelist, player))
            end

            -- Toggle priority
            if table.find(library.priority, player) then
                table.remove(library.priority, table.find(library.priority, player))
                notifications:create_notification({
                    name = "Player List",
                    info = string.format("Removed %s from priority", player),
                    lifetime = 3
                })
            else
                table.insert(library.priority, player)
                notifications:create_notification({
                    name = "Player List",
                    info = string.format("Added %s to priority", player),
                    lifetime = 3
                })
            end
        end
    })

    _section:button({
        name = "Whitelist", 
        callback = function()
            if not flags["player_list"] then 
                notifications:create_notification({
                    name = "Player List",
                    info = "Please select a player first!",
                    lifetime = 3
                })
                return 
            end
            
            local player = flags["player_list"]
            
            -- Remove from priority if present
            if table.find(library.priority, player) then
                table.remove(library.priority, table.find(library.priority, player))
            end

            -- Toggle whitelist
            if table.find(library.whitelist, player) then
                table.remove(library.whitelist, table.find(library.whitelist, player))
                notifications:create_notification({
                    name = "Player List",
                    info = string.format("Removed %s from whitelist", player),
                    lifetime = 3
                })
            else
                table.insert(library.whitelist, player)
                notifications:create_notification({
                    name = "Player List",
                    info = string.format("Added %s to whitelist", player),
                    lifetime = 3
                })
            end
        end
    })

    -- Auto-refresh player list
    local refreshplrs = function()
        local cache = {}
        for _, v in pairs(players:GetPlayers()) do
            if v == lp then continue end
            table.insert(cache, v.Name)
        end
        table.sort(cache)
        
        if plr_list.refresh_options then
            plr_list.refresh_options(cache)
        end
    end

    -- Initial refresh
    task.spawn(refreshplrs)

    -- Auto-update player list
    players.PlayerAdded:Connect(refreshplrs)
    players.PlayerRemoving:Connect(refreshplrs)
    
    -- Auto-save functionality
    if flags.auto_save then
        task.spawn(function()
            while task.wait(30) do -- Auto-save every 30 seconds
                if flags.auto_save then
                    pcall(function()
                        writefile(library.directory .. "/configs/autosave.cfg", library:get_config())
                    end)
                end
            end
        end)
    end
end

-- Enhanced config list update function
function library:update_config_list() 
    if not config_holder then 
        return 
    end
    
    local list = {}
    
    -- Get all config files
    if isfolder(library.directory .. "/configs") then
        for _, file in pairs(listfiles(library.directory .. "/configs")) do
            local name = file:gsub(library.directory .. "/configs\\", ""):gsub(".cfg", ""):gsub(library.directory .. "\\configs\\", "")
            if name ~= "" then
                table.insert(list, name)
            end
        end
    end
    
    -- Add default configs if none exist
    if #list == 0 then
        table.insert(list, "Default")
        table.insert(list, "Backup")
    end
    
    -- Sort alphabetically
    table.sort(list)
    
    if config_holder.refresh_options then
        config_holder.refresh_options(list)
    end
end 

-- Enhanced get_config function
function library:get_config()
    local Config = {}
    
    -- Save all flags
    for flag_name, flag_value in pairs(flags) do
        if type(flag_value) == "table" and flag_value.key then
            -- Keybind flags
            Config[flag_name] = {
                active = flag_value.active, 
                mode = flag_value.mode, 
                key = tostring(flag_value.key)
            }
        elseif type(flag_value) == "table" and flag_value["Transparency"] and flag_value["Color"] then
            -- Colorpicker flags
            Config[flag_name] = {
                Transparency = flag_value["Transparency"], 
                Color = flag_value["Color"]:ToHex()
            }
        else
            -- Regular flags
            Config[flag_name] = flag_value
        end
    end 
    
    -- Save theme settings
    Config["theme_accent"] = themes.preset.accent:ToHex()
    
    -- Save player lists
    Config["priority_players"] = library.priority or {}
    Config["whitelist_players"] = library.whitelist or {}
    
    return http_service:JSONEncode(Config)
end

-- Enhanced load_config function
function library:load_config(config_json) 
    local success, config = pcall(function()
        return http_service:JSONDecode(config_json)
    end)
    
    if not success then
        notifications:create_notification({
            name = "Configs",
            info = "Failed to load config: Invalid format",
            lifetime = 5
        })
        return
    end
    
    for flag_name, flag_value in pairs(config) do 
        local function_set = library.config_flags[flag_name]
        
        if flag_name == "config_name_list" then 
            continue 
        end
        
        -- Handle theme settings
        if flag_name == "theme_accent" then
            library:update_theme("accent", hex(flag_value))
            continue
        end
        
        -- Handle player lists
        if flag_name == "priority_players" then
            library.priority = flag_value or {}
            continue
        end
        
        if flag_name == "whitelist_players" then
            library.whitelist = flag_value or {}
            continue
        end

        if function_set then 
            if type(flag_value) == "table" and flag_value["Transparency"] and flag_value["Color"] then
                -- Colorpicker
                function_set(hex(flag_value["Color"]), flag_value["Transparency"])
            elseif type(flag_value) == "table" and flag_value["active"] then 
                -- Keybind
                function_set(flag_value)
            else
                -- Regular value
                function_set(flag_value)
            end
        end 
    end 
    
    -- Update UI to reflect loaded values
    library:update_config_list()
end 

-- Auto-load last config on startup
task.spawn(function()
    task.wait(1) -- Wait for UI to initialize
    
    local last_config_path = library.directory .. "/configs/autosave.cfg"
    if isfile(last_config_path) then
        pcall(function()
            library:load_config(readfile(last_config_path))
            notifications:create_notification({
                name = "Configs",
                info = "Auto-loaded last config",
                lifetime = 3
            })
        end)
    end
end)

return library
